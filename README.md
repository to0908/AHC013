# AHC013

## adhoc 考察
- TLは3secです

- seedによってSolverの切り替えが必要になりそう
    - Kの大きさ
    - 密度

- 最終の配置を決め打ちすると最適な移動が求まる？
- Connectの方法によっては別のConnectが阻害されることがある

- 配置が決まったときに最も高いスコアになるConnectを求めることができるか
    - x個同じ + y個同じ : + x*y 点 
        - 全体で (x+1) * x / 2 点
    - x個同じ + y個異なる : - x*y点 
        - 全体で (x+1) * x / 2 + (y+1) * y / 2 - x*y 点
    
- できるだけ少ないMoveの後、たくさんConnectしたい
    - Moveだけ焼きなましとかビームで、ConnectはDPとかフローとか貪欲とか(中身は何も考えていない)みたいな感じか？

- (1いっぱい)-(2が1個)-(1いっぱい)みたいな連結も得になる
    - 最終的にこういうのは採用しないようになるかもしれない

- (残りの操作回数が十分にある場合に)デメリットのない連結
    - 完全に隣り合っているペア
    - 端同士
    
- 疎なものはできるだけ高得点を取りたい
    - 他の種類のサーバーの連結を邪魔せず、移動回数が少なく、ほとんどすべて連結にできるようなものが見つけられるか

- 貪欲に損にならない連結をやっていくだけでかなりの操作回数を使ってしまうので、Moveをある程度行うことを考えると、
    Scoreが大きくなるところだけに絞る必要がありそう

- 小さい連結成分をたくさん作るよりも大きな成分を1つ作る方が強い
    - スコアはサイズの2乗になる
    - 

- K*100 - 99回移動して1を100個集める 
    - Score = 100 * 99 / 2 = 4950
    - 50ケースで247,500
    - できるだけ少ない回数で100個集めるゲーム？
        - できるだけ少ない回数で100個集める
        - 残り回数で他の連結も行うため、他の種類の連結成分も大きい方が良い
    - とりあえず250,000が最低ラインという気がするが、上位は何をやっているのか
        - 100に近いのを最初に作る → 残りでいい感じにという方針なのか、そんなことせずに適当にビームとか焼きなましでいい感じになるのか

## メタヒューリスティクス考察
- 焼きなましは無理そう

- 密Solver
    - Move: 空白マスを持って2点swapのビームをする
        - 評価関数としては、Connectの方法は考えずに、SUM(同じ種類の隣接連結成分の個数**2) - len(move)みたいな？
            - SUM(種類iの連結成分のMAX for i in range(K))とかは？
            - UFっぽいことをする
            - 親と個数を分かるようにしておく+親は全子を持っておく？で、swapされると
                - 子が離れるなら、その子は新しい親(サイズ1)になるか、他の連結成分にくっつく
                - 親が離れるなら、子の中から新しい親を決めて全ての子の親を新しい親に更新
                - 子は常に最新の親を持っておく必要がある
                - vector< vector< int > > v とかで、v[i][j]=i個目の連結成分のj個目の要素で、j==0なら親、みたいな
                    - それと各サーバーに番号を振っておき、server[x] = (i, j) みたいなことをする
                    - 操作はerase, push_backでOK
            - 完全に隣接じゃないもの(1個開きとか)をどうするか
                - これを適切にやらないと余計な移動が発生するし、最適解も逃しそう

- 疎Solver
    - Serverを持ってビーム
        - 最初に各Cellについて距離XのCellを全列挙しておく
            - 距離Xに行けるかどうかの判定が入ってくる
            - 結局BFSをするしかない？
        - 焼きなましの遷移では、「あるサーバーを距離XのあるCellに移動させる」(Xは小さめ)とかにする？



## 実装考察
- Score 計算高速化
- Connect 高速化
    - UFとかででやると操作を戻したりしないといけないので困る

- 座標は1つのint型で表せる
    - field[N * N]
    - %とか割り算とかをできるだけ使わないような実装は？
    - なんならField自体をlong long型で表せるな
        - (48 * 48) ^ 5 = 64,925,062,108,545,024
        - しかしこれ嬉しいか？
        -> 5^(48*48)では？？？

- Move, Connect Action は1つのlong long型で表せる
    - (48 * 48) ^ 4 = 28,179,280,429,056
    - かと言ってこれが嬉しいかというと？
        - 高速に復元できると良い
        -> ビームサーチで嬉しいね

## TODO
- 評価値計算、差分だけ見るように